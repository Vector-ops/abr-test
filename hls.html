<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>hls.js current quality demo</title>
        <style>
            #currentQuality {
                font-family: system-ui, sans-serif;
                font-size: 13px;
                padding: 6px 10px;
                background: rgba(0, 0, 0, 0.6);
                color: #fff;
                display: inline-block;
                border-radius: 4px;
                position: absolute;
                top: 12px;
                left: 12px;
                z-index: 10;
            }
            video {
                width: 100%;
                max-width: 900px;
                height: auto;
                display: block;
            }
            .wrap {
                position: relative;
                display: inline-block;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div id="currentQuality">Quality: detecting…</div>
            <video id="video" controls></video>
        </div>

        <!-- hls.js from CDN -->
        <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
        <script>
            const video = document.getElementById("video");
            const qEl = document.getElementById("currentQuality");
            const src = "http://localhost:8000/hls/abr-5/master.m3u8"; // your URL

            function formatKbps(bps) {
                if (!bps) return "";
                return " (" + Math.round(bps / 1000) + " kbps)";
            }

            function updateUIFromLevel(levelIndex, levelsArray) {
                if (
                    levelIndex == null ||
                    !levelsArray ||
                    !levelsArray[levelIndex]
                ) {
                    qEl.textContent = "Quality: unknown";
                    return;
                }
                const level = levelsArray[levelIndex];
                // some manifests include width/height, some do not
                const height =
                    level.height ||
                    (level.attrs &&
                        level.attrs.RESOLUTION &&
                        level.attrs.RESOLUTION.height) ||
                    null;
                const bw =
                    level.bitrate ||
                    level.bandwidth ||
                    level.bandwidthEstimate ||
                    null;
                qEl.textContent =
                    "Quality: " +
                    (height ? height + "p" : "level " + levelIndex) +
                    formatKbps(bw);
            }

            if (Hls.isSupported()) {
                const hls = new Hls({
                    // tweak ABR params if needed
                    // maxBufferLength: 30,
                    // fragLoadingTimeOut: 20000,
                });

                hls.attachMedia(video);

                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    hls.loadSource(src);
                });

                // when playlist/levels parsed
                hls.on(Hls.Events.MANIFEST_PARSED, (ev, data) => {
                    console.log(
                        "Manifest parsed, available levels:",
                        hls.levels,
                    );
                    // start playback if you want
                    // video.play();
                    updateUIFromLevel(hls.currentLevel, hls.levels);
                });

                // event emitted when hls.js decides to switch levels (internal)
                hls.on(Hls.Events.LEVEL_SWITCHED, (ev, data) => {
                    // data.level = new level index
                    updateUIFromLevel(data.level, hls.levels);
                });

                // when a fragment is loaded we can also read frag.level (useful to show the actually downloaded one)
                hls.on(Hls.Events.FRAG_LOADED, (ev, data) => {
                    // data.frag.level is the level index used for this fragment
                    updateUIFromLevel(data.frag.level, hls.levels);
                });

                // You can also monitor bandwidthEstimate from the ABR controller
                hls.on(Hls.Events.FRAG_BUFFERED, () => {
                    const bwe = hls.bandwidthEstimate || null; // bytes per second
                    // some players expose bytes/sec; hls.bandwidthEstimate is bits/sec in some builds — safe to display if present
                    // optional: show bandwidth estimate somewhere
                });

                // Fallback polling in case of very fast/quiet switches
                setInterval(() => {
                    // prefer hls.loadLevel (the level currently being loaded) or hls.currentLevel
                    const levelIndex =
                        typeof hls.loadLevel === "number" && hls.loadLevel >= 0
                            ? hls.loadLevel
                            : hls.currentLevel;
                    updateUIFromLevel(levelIndex, hls.levels);
                }, 700);
            } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
                // Safari (native HLS). We can't control ABR but can attempt to infer resolution from video.videoWidth/videoHeight
                video.src = src;
                video.addEventListener("loadedmetadata", () => {
                    qEl.textContent =
                        "Quality: " +
                        (video.videoHeight
                            ? video.videoHeight + "p"
                            : "native");
                });
                // keep updating for native switches (some browsers change videoWidth/videoHeight)
                setInterval(() => {
                    if (video.videoHeight)
                        qEl.textContent =
                            "Quality: " + (video.videoHeight + "p");
                }, 1000);
            } else {
                qEl.textContent = "No HLS support";
            }
        </script>
    </body>
</html>
